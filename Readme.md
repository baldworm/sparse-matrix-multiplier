# Произведение разреженных целочисленных матриц

## Хранение разреженных матриц

#### Параметры матрицы

> `dencity` - плотность матрицы
>
> `columnsNum` - количество колонок
>
> `rowsNum` - количество строк

В базовом случае матрица занимает
 
```initSize = columnsNum * rowsNum * longSize```

Большую часть матрицы занимают нулевые элементы. Цель - оптимизировать хранение.

Реализуем разреженный строчный формат (Compressed Row Storage, CRS). 
Для этого создадим 3 массива:


>`values[]` - храним все ненулевые значения, обходя матрицу слева направо сверху вниз. 
>
>`columnIndices[]` - храним индексы колонок значений из `values[]`  
>    
>`rowPointers[]` - массив указателей позиций `values[]` на которых происходит переход на следующую строчку.


Таким образом, получаем структуру данных, которая занимает:

```crsSize = density * columnsNum * rowsNum * (longSize + intSize) + rowNum * intSize```

Например, для матрицы 1000x1000 с плотностью заполнения 0.01 получаем:

```initSize = 8 * 10^6 ```

```crsSize = 12 * 10^4  + 4 * 10^3```

А в пределе, получаем выигрыш в `2/3 * 1 / density`

## Произведение разреженных матриц 

План перемножения CRS-матрицы A на B выглядит следующим образом: 
1. Транспонировать матрицу B
2. Перемножить каждую строку матрицы A на каждую строку транспонированной матрицы B

Для реализации 1-го пункта, создал временное 2-d хранилище, куда закидывал элементы с нужными индексами.
Поэтом просто выпрямил его, получив нужную структуру.

Для реализации 2-го пункта реализовал итератор, который ходит сразу по двум "срезам" `columnIndices`, находя совпадения.   



## PS.
##### Нереализованный функционал.
Метод `set()` не умеет добавлять новые элементы (в задаче и не было)

Метод `transpose()` не доделан, не оптимизирован, используется лишнее место

Метод `multiply()` не готов, не проверен 

##### Как можно улучшить?

1. Есть более выгодные алгоритмы транспонирования и перемножения матрицы, можно реализовать их
2. Распараллелить перемножение строк
3. Ещё больше распараллелить, использовать Nvidia Cuda
4. А может TPU ? :) 

##### Почему используются обычные массивы?
Бенчмарк показал, что ArrayList работает в 2-3 раза медленнее

    Benchmark matrix 1000x1000           Mode  Cnt  Score    Error  Units
    SpeedTest.getElementTestNativeArray  avgt   10  0,077 ±  0,001   s/op
    SpeedTest.getElementTestArrayList    avgt   10  0,202 ±  0,001   s/op
    
    Benchmark matrix 10000x10000       Mode  Cnt  Score   Error  Units
    SpeedTest.getElementTestNativeArray  avgt   10  4,183 ± 0,107   s/op
    SpeedTest.getElementTestArrayList    avgt   10  9,735 ± 0,144   s/op

